"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_extra_1 = __importDefault(require("fs-extra"));
var path_1 = __importDefault(require("path"));
var child_process_1 = require("child_process");
var dns_1 = __importDefault(require("dns"));
var url_1 = __importDefault(require("url"));
var os_1 = __importDefault(require("os"));
var cross_spawn_1 = __importDefault(require("cross-spawn"));
var semver_1 = __importDefault(require("semver"));
var chalk_1 = __importDefault(require("chalk"));
var validate_npm_package_name_1 = __importDefault(require("validate-npm-package-name"));
function generateProject(_a) {
    var name = _a.name, type = _a.type, language = _a.language, useNpm = _a.useNpm, usePnp = _a.usePnp, verbose = _a.verbose, appType = _a.appType, checkAppNames = _a.checkAppNames, templatePackageName = _a.templatePackageName;
    var template = type + "/" + language;
    var useTypeScript = language === 'typescript';
    checkNodeVersion(useTypeScript);
    var root = path_1.default.resolve(name);
    var appName = path_1.default.basename(root);
    checkAppName(appName, checkAppNames);
    fs_extra_1.default.ensureDirSync(name);
    if (!isSafeToCreateProjectIn(root, name)) {
        process.exit(1);
    }
    console.log();
    console.log("Creating a new " + appType + " app in " + chalk_1.default.green(root) + ".");
    console.log();
    var packageJson = {
        name: appName,
        version: '0.0.1',
        private: true,
    };
    fs_extra_1.default.writeFileSync(path_1.default.join(root, 'package.json'), JSON.stringify(packageJson, null, 2) + os_1.default.EOL);
    var useYarn = useNpm ? false : shouldUseYarn();
    var originalDirectory = process.cwd();
    process.chdir(root);
    if (!useYarn && !checkThatNpmCanReadCwd()) {
        process.exit(1);
    }
    if (!useYarn) {
        var npmInfo = checkNpmVersion();
        if (!npmInfo.hasMinNpm) {
            if (npmInfo.npmVersion) {
                console.log(chalk_1.default.yellow("You are using npm " + npmInfo.npmVersion + " so the project will be bootstrapped with an old unsupported version of tools.\n\n" +
                    "Please update to npm 5 or higher.\n"));
            }
        }
    }
    else if (usePnp) {
        var yarnInfo = checkYarnVersion();
        if (!yarnInfo.hasMinYarnPnp) {
            if (yarnInfo.yarnVersion) {
                console.log(chalk_1.default.yellow("You are using Yarn " + yarnInfo.yarnVersion + " together with the --use-pnp flag, but Plug'n'Play is only supported starting from the 1.12 release.\n\n" +
                    "Please update to Yarn 1.12 or higher.\n"));
            }
            // 1.11 had an issue with webpack-dev-middleware, so better not use PnP with it (never reached stable, but still)
            usePnp = false;
        }
    }
    if (useYarn) {
        var yarnUsesDefaultRegistry = true;
        try {
            yarnUsesDefaultRegistry =
                child_process_1.execSync('yarn config get registry').toString().trim() ===
                    'https://registry.yarnpkg.com';
        }
        catch (e) {
            // ignore
        }
        if (yarnUsesDefaultRegistry) {
            // TODO: copy `yarn.lock`?
        }
    }
    run(templatePackageName, root, appName, verbose, originalDirectory, template, useYarn, usePnp);
}
exports.generateProject = generateProject;
function run(templatePackageName, root, appName, verbose, originalDirectory, template, useYarn, usePnp) {
    return __awaiter(this, void 0, void 0, function () {
        var allDependencies, isOnline, templateBasePath, templateDir, appPath, gitignoreExists, data, appPackagePath, appPackage, templateJsonPath, templateJson, dependencies, dependencies, reason_1, knownGeneratedFiles_1, currentFiles, remainingFiles;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 7, , 8]);
                    allDependencies = [templatePackageName];
                    console.log('Installing packages. This might take a couple of minutes.');
                    return [4 /*yield*/, checkIfOnline(useYarn)];
                case 1:
                    isOnline = _a.sent();
                    allDependencies.push(templatePackageName);
                    console.log("Installing " + chalk_1.default.cyan(templatePackageName) + " ...");
                    console.log();
                    return [4 /*yield*/, install(root, useYarn, usePnp, allDependencies, verbose, isOnline, true)];
                case 2:
                    _a.sent();
                    templateBasePath = path_1.default.resolve("node_modules/" + templatePackageName + "/templates/" + template);
                    templateDir = path_1.default.join(templateBasePath, "template");
                    appPath = process.cwd();
                    if (fs_extra_1.default.existsSync(templateDir)) {
                        fs_extra_1.default.copySync(templateDir, appPath);
                    }
                    else {
                        console.error("Could not locate supplied template: " + chalk_1.default.green(templateDir));
                        return [2 /*return*/];
                    }
                    gitignoreExists = fs_extra_1.default.existsSync(path_1.default.join(appPath, '.gitignore'));
                    if (gitignoreExists) {
                        data = fs_extra_1.default.readFileSync(path_1.default.join(appPath, 'gitignore'));
                        fs_extra_1.default.appendFileSync(path_1.default.join(appPath, '.gitignore'), data);
                        fs_extra_1.default.unlinkSync(path_1.default.join(appPath, 'gitignore'));
                    }
                    else {
                        fs_extra_1.default.moveSync(path_1.default.join(appPath, 'gitignore'), path_1.default.join(appPath, '.gitignore'));
                    }
                    appPackagePath = path_1.default.join(appPath, "package.json");
                    appPackage = {};
                    if (fs_extra_1.default.existsSync(appPackagePath)) {
                        appPackage = require(appPackagePath);
                    }
                    else {
                        // TODO:
                        console.error("Template of 'package.json' does not exist: " + chalk_1.default.green(appPackagePath));
                        return [2 /*return*/];
                    }
                    templateJsonPath = path_1.default.join(templateBasePath, "template.json");
                    templateJson = {};
                    if (fs_extra_1.default.existsSync(templateJsonPath)) {
                        templateJson = require(templateJsonPath);
                    }
                    if (templateJson.scripts) {
                        Object.assign(appPackage, {
                            scripts: templateJson.scripts,
                        });
                    }
                    if (useYarn && appPackage.scripts) {
                        appPackage.scripts = Object.entries(appPackage.scripts).reduce(function (acc, _a) {
                            var _b;
                            var _c = __read(_a, 2), key = _c[0], value = _c[1];
                            return (__assign(__assign({}, acc), (_b = {}, _b[key] = value.replace(/(npm run |npm )/, 'yarn '), _b)));
                        }, {});
                    }
                    fs_extra_1.default.writeFileSync(appPackagePath, JSON.stringify(appPackage, null, 2) + os_1.default.EOL);
                    removeTemplatePackage(templatePackageName, useYarn);
                    if (!templateJson.devDependencies) return [3 /*break*/, 4];
                    dependencies = Object.entries(templateJson.devDependencies).map(function (_a) {
                        var _b = __read(_a, 2), name = _b[0], version = _b[1];
                        return version === '*' ? name : name + "@" + version;
                    });
                    return [4 /*yield*/, install(root, useYarn, usePnp, dependencies, verbose, isOnline, true)];
                case 3:
                    _a.sent();
                    _a.label = 4;
                case 4:
                    if (!templateJson.dependencies) return [3 /*break*/, 6];
                    dependencies = Object.entries(templateJson.dependencies).map(function (_a) {
                        var _b = __read(_a, 2), name = _b[0], version = _b[1];
                        return version === '*' ? name : name + "@" + version;
                    });
                    return [4 /*yield*/, install(root, useYarn, usePnp, dependencies, verbose, isOnline, false)];
                case 5:
                    _a.sent();
                    _a.label = 6;
                case 6:
                    console.log();
                    console.log(chalk_1.default.green('Created successfully.'));
                    console.log();
                    console.log("Run the following command to start " + chalk_1.default.cyan(appName) + " project:");
                    console.log();
                    console.log("  " + chalk_1.default.cyan("cd " + appName));
                    console.log("  " + chalk_1.default.cyan((useYarn ? 'yarn' : 'npm') + " start"));
                    console.log();
                    return [3 /*break*/, 8];
                case 7:
                    reason_1 = _a.sent();
                    console.log();
                    console.log('Aborting installation.');
                    if (reason_1.command) {
                        console.log("  " + chalk_1.default.cyan(reason_1.command) + " has failed.");
                    }
                    else {
                        console.log(chalk_1.default.red('Unexpected error. Please report it as a bug:'));
                        console.log(reason_1);
                    }
                    console.log();
                    knownGeneratedFiles_1 = ['package.json', 'yarn.lock', 'node_modules'];
                    currentFiles = fs_extra_1.default.readdirSync(path_1.default.join(root));
                    currentFiles.forEach(function (file) {
                        knownGeneratedFiles_1.forEach(function (fileToMatch) {
                            // This removes all knownGeneratedFiles.
                            if (file === fileToMatch) {
                                console.log("Deleting generated file... " + chalk_1.default.cyan(file));
                                fs_extra_1.default.removeSync(path_1.default.join(root, file));
                            }
                        });
                    });
                    remainingFiles = fs_extra_1.default.readdirSync(path_1.default.join(root));
                    if (!remainingFiles.length) {
                        // Delete target folder if empty
                        console.log("Deleting " + chalk_1.default.cyan(appName + "/") + " from " + chalk_1.default.cyan(path_1.default.resolve(root, '..')));
                        process.chdir(path_1.default.resolve(root, '..'));
                        fs_extra_1.default.removeSync(path_1.default.join(root));
                    }
                    console.log('Done.');
                    process.exit(1);
                    return [3 /*break*/, 8];
                case 8: return [2 /*return*/];
            }
        });
    });
}
exports.run = run;
function removeTemplatePackage(templateName, useYarn) {
    var command;
    var remove;
    if (useYarn) {
        command = 'yarn';
        remove = 'remove';
    }
    else {
        command = 'npm';
        remove = 'uninstall';
    }
    console.log("Removing " + templateName + " package...");
    console.log();
    var childProcess = cross_spawn_1.default.sync(command, [remove, templateName], {
        stdio: 'inherit',
    });
    if (childProcess.status !== 0) {
        console.error(command + " failed");
        process.exit(1);
    }
}
exports.removeTemplatePackage = removeTemplatePackage;
function checkNodeVersion(useTypeScript) {
    var unsupportedNodeVersion = !semver_1.default.satisfies(process.version, '>=8.10.0');
    if (unsupportedNodeVersion && useTypeScript) {
        console.error(chalk_1.default.red("You are using Node " + process.version + " with the TypeScript template. Node 8.10 or higher is required to use TypeScript.\n"));
        process.exit(1);
    }
    else if (unsupportedNodeVersion) {
        console.log(chalk_1.default.yellow("You are using Node " + process.version + " so the project will be bootstrapped with an old unsupported version of tools.\n\n" +
            "Please update to Node 8.10 or higher.\n"));
    }
}
exports.checkNodeVersion = checkNodeVersion;
function checkAppName(appName, dependencies) {
    var validationResult = validate_npm_package_name_1.default(appName);
    if (!validationResult.validForNewPackages) {
        console.error(chalk_1.default.red("Cannot create a project named " + chalk_1.default.green("\"" + appName + "\"") + " because of npm naming restrictions:\n"));
        __spread((validationResult.errors || []), (validationResult.warnings || [])).forEach(function (error) {
            console.error(chalk_1.default.red("  * " + error));
        });
        console.error(chalk_1.default.red('\nPlease choose a different project name.'));
        process.exit(1);
    }
    if (dependencies.includes(appName)) {
        console.error(chalk_1.default.red("Cannot create a project named " + chalk_1.default.green("\"" + appName + "\"") + " because a dependency with the same name exists.\n" +
            "Due to the way npm works, the following names are not allowed:\n\n") +
            chalk_1.default.cyan(dependencies.map(function (depName) { return "  " + depName; }).join('\n')) +
            chalk_1.default.red('\n\nPlease choose a different project name.'));
        process.exit(1);
    }
}
exports.checkAppName = checkAppName;
function isSafeToCreateProjectIn(root, name) {
    var e_1, _a;
    var validFiles = [
        '.DS_Store',
        '.git',
        '.gitattributes',
        '.gitignore',
        '.gitlab-ci.yml',
        '.hg',
        '.hgcheck',
        '.hgignore',
        '.idea',
        '.npmignore',
        '.travis.yml',
        'docs',
        'LICENSE',
        'README.md',
        'mkdocs.yml',
        'Thumbs.db',
    ];
    var errorLogFilePatterns = [
        'npm-debug.log',
        'yarn-error.log',
        'yarn-debug.log',
    ];
    var isErrorLog = function (file) {
        return errorLogFilePatterns.some(function (pattern) { return file.startsWith(pattern); });
    };
    var conflicts = fs_extra_1.default
        .readdirSync(root)
        .filter(function (file) { return !validFiles.includes(file); })
        .filter(function (file) { return !/\.iml$/.test(file); })
        .filter(function (file) { return !isErrorLog(file); });
    if (conflicts.length > 0) {
        console.log("The directory " + chalk_1.default.green(name) + " contains files that could conflict:");
        console.log();
        try {
            for (var conflicts_1 = __values(conflicts), conflicts_1_1 = conflicts_1.next(); !conflicts_1_1.done; conflicts_1_1 = conflicts_1.next()) {
                var file = conflicts_1_1.value;
                try {
                    var stats = fs_extra_1.default.lstatSync(path_1.default.join(root, file));
                    if (stats.isDirectory()) {
                        console.log("  " + chalk_1.default.blue(file + "/"));
                    }
                    else {
                        console.log("  " + file);
                    }
                }
                catch (e) {
                    console.log("  " + file);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (conflicts_1_1 && !conflicts_1_1.done && (_a = conflicts_1.return)) _a.call(conflicts_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        console.log();
        console.log('Either try using a new directory name, or remove the files listed above.');
        return false;
    }
    fs_extra_1.default.readdirSync(root).forEach(function (file) {
        if (isErrorLog(file)) {
            fs_extra_1.default.removeSync(path_1.default.join(root, file));
        }
    });
    return true;
}
exports.isSafeToCreateProjectIn = isSafeToCreateProjectIn;
function shouldUseYarn() {
    try {
        child_process_1.execSync('yarn --version', { stdio: 'ignore' });
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.shouldUseYarn = shouldUseYarn;
function checkThatNpmCanReadCwd() {
    var cwd = process.cwd();
    var childOutput = null;
    try {
        childOutput = cross_spawn_1.default.sync('npm', ['config', 'list']).output.join('');
    }
    catch (err) {
        return true;
    }
    if (typeof childOutput !== 'string') {
        return true;
    }
    var lines = childOutput.split('\n');
    var prefix = '; cwd = ';
    var line = lines.find(function (line) { return line.startsWith(prefix); });
    if (typeof line !== 'string') {
        return true;
    }
    var npmCWD = line.substring(prefix.length);
    if (npmCWD === cwd) {
        return true;
    }
    console.error(chalk_1.default.red("Could not start an npm process in the right directory.\n\n" +
        ("The current directory is: " + chalk_1.default.bold(cwd) + "\n") +
        ("However, a newly started npm process runs in: " + chalk_1.default.bold(npmCWD) + "\n\n") +
        "This is probably caused by a misconfigured system terminal shell."));
    if (process.platform === 'win32') {
        console.error(chalk_1.default.red("On Windows, this can usually be fixed by running:\n\n") +
            ("  " + chalk_1.default.cyan('reg') + " delete \"HKCU\\Software\\Microsoft\\Command Processor\" /v AutoRun /f\n") +
            ("  " + chalk_1.default.cyan('reg') + " delete \"HKLM\\Software\\Microsoft\\Command Processor\" /v AutoRun /f\n\n") +
            chalk_1.default.red("Try to run the above two lines in the terminal.\n") +
            chalk_1.default.red("To learn more about this problem, read: https://blogs.msdn.microsoft.com/oldnewthing/20071121-00/?p=24433/"));
    }
    return false;
}
exports.checkThatNpmCanReadCwd = checkThatNpmCanReadCwd;
function checkNpmVersion() {
    var hasMinNpm = false;
    var npmVersion = null;
    try {
        npmVersion = child_process_1.execSync('npm --version').toString().trim();
        hasMinNpm = semver_1.default.gte(npmVersion, '5.0.0');
    }
    catch (err) {
        // ignore
    }
    return {
        hasMinNpm: hasMinNpm,
        npmVersion: npmVersion,
    };
}
exports.checkNpmVersion = checkNpmVersion;
function checkYarnVersion() {
    var minYarnPnp = '1.12.0';
    var hasMinYarnPnp = false;
    var yarnVersion = null;
    try {
        yarnVersion = child_process_1.execSync('yarn --version').toString().trim();
        if (semver_1.default.valid(yarnVersion)) {
            hasMinYarnPnp = semver_1.default.gte(yarnVersion, minYarnPnp);
        }
        else {
            var trimmedYarnVersionMatch = /^(.+?)[-+].+$/.exec(yarnVersion);
            if (trimmedYarnVersionMatch) {
                var trimmedYarnVersion = trimmedYarnVersionMatch.pop();
                hasMinYarnPnp = semver_1.default.gte(trimmedYarnVersion, minYarnPnp);
            }
        }
    }
    catch (err) {
        // ignore
    }
    return {
        hasMinYarnPnp: hasMinYarnPnp,
        yarnVersion: yarnVersion,
    };
}
exports.checkYarnVersion = checkYarnVersion;
function getProxy() {
    if (process.env.https_proxy) {
        return process.env.https_proxy;
    }
    else {
        try {
            // Trying to read https-proxy from .npmrc
            var httpsProxy = child_process_1.execSync('npm config get https-proxy').toString().trim();
            return httpsProxy !== 'null' ? httpsProxy : undefined;
        }
        catch (e) {
            return;
        }
    }
}
function checkIfOnline(useYarn) {
    if (!useYarn) {
        // Don't ping the Yarn registry.
        // We'll just assume the best case.
        return Promise.resolve(true);
    }
    return new Promise(function (resolve) {
        dns_1.default.lookup('registry.yarnpkg.com', function (err) {
            var proxy;
            if (err != null && (proxy = getProxy())) {
                // If a proxy is defined, we likely can't resolve external hostnames.
                // Try to resolve the proxy name as an indication of a connection.
                dns_1.default.lookup(url_1.default.parse(proxy).hostname, function (proxyErr) {
                    resolve(proxyErr == null);
                });
            }
            else {
                resolve(err == null);
            }
        });
    });
}
exports.checkIfOnline = checkIfOnline;
function install(root, useYarn, usePnp, dependencies, verbose, isOnline, isDev) {
    return new Promise(function (resolve, reject) {
        var command;
        var args;
        if (useYarn) {
            command = 'yarn';
            args = ['add', '--exact'];
            if (isDev) {
                args.push('--dev');
            }
            if (!isOnline) {
                args.push('--offline');
            }
            if (usePnp) {
                args.push('--enable-pnp');
            }
            [].push.apply(args, dependencies);
            args.push('--cwd');
            args.push(root);
            if (!isOnline) {
                console.log(chalk_1.default.yellow('You appear to be offline.'));
                console.log(chalk_1.default.yellow('Falling back to the local Yarn cache.'));
                console.log();
            }
        }
        else {
            command = 'npm';
            args = [
                'install',
                isDev ? '--save-dev' : '--save',
                '--save-exact',
                '--loglevel',
                'error',
            ].concat(dependencies);
            if (usePnp) {
                console.log(chalk_1.default.yellow("NPM doesn't support PnP."));
                console.log(chalk_1.default.yellow('Falling back to the regular installs.'));
                console.log();
            }
        }
        if (verbose) {
            args.push('--verbose');
        }
        var child = cross_spawn_1.default(command, args, { stdio: 'inherit' });
        child.on('close', function (code) {
            if (code !== 0) {
                reject({
                    command: command + " " + args.join(' '),
                });
                return;
            }
            resolve();
        });
    });
}
exports.install = install;
//# sourceMappingURL=index.js.map